```c++
#include<valarray>
```
模板类valarray，与vector和array类似，能够支持更多函数

关键字```explicit``` 关闭隐式转换

## 包含 私有继承 保护继承

包含对象成员的类
对继承的对象而言，需要在构造函数中使用初始化列表来进行构建
如果省略初始化列表，将使用成员对象所属类的默认构造函数

私有继承
基类的公有成员和保护成员都将成为派生类的私有成员
基类方法不会是派生对象共有接口的一部分，但可以在派生类的成员函数中使用

**包含**将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中

使用包含时，使用对象名来调用方法
使用私有继承时，使用类名和作用域解析运算符来调用方法
私有继承时如果要使用基类对象本身，需要时哦耶那个强制类型转换

包含更为常用
包含可以避免继承(尤其是从多个基类继承)出现的问题，还能够包括多个同类的子对象

私有继承能够访问基类的保护成员，包含不能
私有继承时派生类能重新定义虚函数，包含不能
使用私有继承时，重新定义的函数只能在类中使用，而不是公有的

**通常，应使用包含来建立has-a关系；如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承**

保护继承是私有继承的变体
使用保护继承时，基类的公有成员和保护成员都将成为派生类的保护成员
基类的接口在派生类中可用，但在继承层次结构外不可用
第三代类仍可以使用基类的接口

## 多重继承

**虚基类**：使得从多个从该类派生出的对象只继承一个基类对象
在类声明中使用关键字```virtual```
例如：
```c++
class Singer : virtual public Worker {...};
class Waiter : virtual public Worker {...};

class SingingWaiter : public Singer, public Waiter {...};
```
SingingWaiter对象将只包含Worker对象的一个副本
继承的Singer和Waiter对象共享一个Worker对象

**构造函数规则**
构造函数自动传递对于虚基类将不起作用
编译器会使用虚基类的默认构造函数来构造虚基类对象
如果不希望这样，需要显示地调用所需的基类构造函数

多重继承的两个基类如果有命名相同的函数方法，调用时需要使用作用域解析计算符```::```

## 类模板

```c++
template <class Type>
class Stack
{
    ...
};
```

还有一种 非类型参数/表达式参数
```c++
template <class T, int n>
class ArrayTP 
{
    ...
};
```
这其中```class```指出T为类型参数，int指出n的类型为int
指定特殊的类型而不是用作泛型名 成为非类型或表达式参数

表达式参数方法的主要缺点是 每种数组大小都将生成自己的模板

模板类声明也可以有友元，有三类：
* 非模板友元
* 约束bound模板友元，即友元的类型取决于类被实例化时的类型
* 非约束unbound模板友元，即友元的所有具体化都是类的每一个具体化的友元